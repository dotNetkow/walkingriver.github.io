---
layout: post
title: Why You Should Consider MVC 2 for Your Next ASP.NET Web Site
date: '2010-05-12T10:00:00.010-04:00'
author: Michael Callaghan
tags:
- ASP.NET MVC
modified_time: '2010-05-26T11:57:33.319-04:00'
blogger_id: tag:blogger.com,1999:blog-2890709913211146020.post-7028835393145171189
blogger_orig_url: http://www.walkingriver.com/2010/05/why-choose-mvc-2-for-your-next-aspnet.html
---

You have many choices when you set out to design a new web site. Some people might say that you have too many choices. For the purposes of this article, I'm going to assume that you've already decided that you're going to use ASP.NET in one form or another, so won't presume to debate the merits of Windows versus Linux hosting. Instead I'm going to focus on a real project where we chose MVC Release 2 for a redesign of an existing ASP.NET WebForms site.
<!--more-->
<br /><br /><div>There are four main reasons that helped us decide on using ASP.NET MVC for  our project:</div><ul><li>Testability  </li><li>Clean, SEO-Friendly URLs</li><li>Full Control of the HTML generated</li><li>We got to <i>delete a lot of code</i>!</li></ul><div><b>Testability</b></div><div>By default, MVC projects encourage the practice of test-driven development.  Each controller can be paired with a controller test class that exercises the  controller's functionality without regard to the view that will ultimately  render in the UI. Testing each controller's methods in this way ensures a clean  separation of UI and logic. Done correctly, it is possible to build a UI layer  with absolutely no code-behind (which isn't supported in a MVC project in the  first place).</div><div></div><div><b>Clean, SEO-Friendly URLs</b></div><div>Let's face it. URLs that look like this are so last decade!</div><div><a href="http://eleganceincoding.blogspot.com/2010/05/why-choose-mvc-2-for-your-next-aspnet.html">http://www.blogger.com/viewblog.php?blogID=2890709913211146020&amp;postID=7028835393145171189&nbsp; </a>  </div><div></div><div><br />Plus, from a practical point of view, the above URL isn't very  search-engine friendly. Search engines tend to ignore the query string in a URL  (everything after the question mark). Thus, in the above example, search engines  would treat all the URLs to years' worth of articles as the exact same link.  This is not good if you want your articles to be found.</div><div></div><div>A better choice would be to allow URLs like this: <br /><a href="http://eleganceincoding.blogspot.com/2010/05/why-choose-mvc-2-for-your-next-aspnet.html">http://eleganceincoding.blogspot.com/2010/05/</a></div><br /><div>Using this method, each of your articles would have a unique URL. Each  article would thus be individually indexed by search engines. It can be made  better, still. Imagine if someone were to bookmark the above URL so that they  could come back to the article later. It's not very human-readable, and months  later, may not mean much. </div><div></div><div>Consider instead the following URL:</div><div><a href="http://eleganceincoding.blogspot.com/2010/05/why-choose-mvc-2-for-your-next-aspnet.html">http://www.example.com/articles/2010/05/why-choose-mvc-2-for-your-next-aspnet.html</a></div><div><br />This URL is both search-engine friendly <i>and </i>human friendly. Humans  can look at the URL and know immediately what the article is about. Search  engines can often do the same. With the term "mvc" in the URL (and presumably  the title and body of the page), how much more relevant will the page appear  than the prior URL?</div><div></div><div>Until recently, creating this type of URL required a technique known as URL  rewriting. The web server would parse the URL into pieces, usually using  regular-expression matching, and then change the URL to look more like the first  example above. </div><div></div><div>ASP.NET MVC uses a routing engine to manage the URLs, and no rewriting  actually occurs. Instead, the routing engine processes the URL and determines  which action method to call on the appropriate controller. </div><div></div><div>This means that the URL <a href="http://eleganceincoding.blogspot.com/2010/05/why-choose-mvc-2-for-your-next-aspnet.html">http://eleganceincoding.blogspot.com/2010/05/why-choose-mvc-2-for-your-next-aspnet.html</a>  might be processed by the ASP.NET routing engine to call the following method on  the ArticleController class:</div><div></div><pre class="brush: csharp">public ActionResult Display(int year, int month, string title)</pre><br />The really cool thing about this strategy is that the article title can exist solely for the benefit of bookmarks and search engines, and then totally ignored by the controller. It can simply continue to look up the article by year/month. Of course, that assumes you only have one article per month. Another great thing about these routes is that you can change them practically on the fly, say to add an article ID, and the framework will automatically adjust. I'll touch on routing basics in a future article.<br /><br /><div><b>Full Control of HTML Generated</b></div><div>One of the (many) criticisms of Web Forms is the lousy HTML generated by the ASP server engine, particularly if you want to use a pure CSS-based layout. Recent versions of Web Forms have addressed this shortcoming, but if you want absolute and total control over your HTML, it's hard to beat the clean pages you can create within the MVC framework. We managed to build 100% tableless CSS-based layouts in our project, with no ViewState. I'll touch on that in more detail at a later time.</div><div><br /></div><b>We Got to Delete a Lot of Code</b><br />One of my favorite development pastimes  is refactoring. Due to its inherent testability, ASP.NET MVC makes it easy to refactor your code. So if you decide that there may be a better way to do something, go ahead and try it. Your tests, if well written, will help you remain confident that you haven't broken anything.<br /><br />The best type of refactoring is when you get to delete huge bloated sections of code and replace it with almost nothing. My favorite example is one web page that simply displayed a specific record from the database for the user to edit. The original Web Forms .aspx page and its accompanying code-behind file were literally hundreds of lines long. There was code to handle localization of form labels, pre-processing of data prior to its display, server-side validation, calls to the database, and a lot of event handlers.<br /><br />By the time I was finished, the entire page had been separated into two action methods on the controller, with fewer than a dozen lines of code between them. The View that generated the HTML form to the user ended up being 33 lines, including whitespace and comments. <i>Now that's what I call deleting code! </i>Less code is a good thing. Small classes and method are dramatically easier to test and maintain than large classes.<br /><br />Later, when I discuss views and view models in more detail, I'll explain how this was all possible. <br /><br /><div></div><div><b>Pulling It All Together</b></div><div>One thing that I'd like to point out is that when building an MVC site, the page URL and the action method tied to it, are  completely decoupled from the UI that will actually be displayed to the  user. Although it is possible for an action method to return HTML, it's not considered a  best practice. So I won't even discuss it here.</div><div></div><div>Instead, the Display() method returns an ActionResult, which is a special  object in ASP.NET MVC. The default implementation of any action method is to  return a View object. In fact, when you first create an action method in Visual  Studio, the auto-generated method will look like this.</div><div></div><pre class="brush: csharp">public ActionResult Display()<br />{<br />&nbsp;&nbsp; return View();<br />}<br /></pre><div></div><div>Believe it or not, this amount of code is all you need to get <i>something  </i>to display in the web browser, assuming you create a view called Display.aspx. But I'm getting ahead of myself. </div>