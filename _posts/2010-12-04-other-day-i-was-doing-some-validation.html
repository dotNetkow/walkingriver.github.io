---
layout: post
title: Data Validation with Non-Inclusive Range Validator
date: '2010-12-04T13:01:00.004-05:00'
author: Michael Callaghan
tags:
- ASP.NET MVC
- Data Annoation
- Validation
modified_time: '2012-04-18T15:39:40.517-04:00'
blogger_id: tag:blogger.com,1999:blog-2890709913211146020.post-2514795235117285439
blogger_orig_url: http://www.walkingriver.com/2010/12/other-day-i-was-doing-some-validation.html
---

The other day I was doing some validation for a few of my class's numeric properties. The valid range, I was told, was 0 to infinity. That's easy enough, I told myself. I'll just put a [Range] attribute each property and let the framework do its thing, like so...
<!--more-->
<br /><br /><pre class="prettyprint">[Range(0,double.MaxValue,ErrorMessage="Please specify a value greater than or equal to zero.")]</pre><br />After publishing the web site to the staging server, I got an email from the client saying that 0 was not a valid value for some of the properties. My first thought was simply to change my range attribute this way:<br /><br /><pre class="prettyprint">Range(0.00000000001,double.MaxValue,ErrorMessage="Please specify a value greater than or equal to zero.")]</pre><br />After all, who's going to type that many zeros? I still wasn't happy with that solution, so I started considering my alternatives. IDataErrorInfo was a definite option, and that would look this:<br /><br /><pre class="prettyprint">public string this[string propertyName]<br />{<br />   get<br />   {<br />      switch (propertyName)<br />      {<br />          case "NonZeroNumericProperty":<br />              if (NonZeroNumericProperty == 0) return "Please enter a value greater than zero";<br />              break;<br />          ...<br />      }<br />   }<br />}</pre><br />Notice that I only checked for a value equal to zero, as the Range attribute still makes sure that the value isn't less than zero. I have two problems with this approach: the first is that my validation for this property is sitting in two different places. The second is that the "this" property from IDataErrorInfo gets really long and ugly really fast. Sure, sometimes there is no better way, but in this case, I think I found one that is both elegant and lets me keep my validation rules together near the relevant property where it can be seen and easily changed.<br /><br />So I created a new custom validation attribute called NonZeroAttribute that makes sure the property's value isn't zero. Combined with the [Range] attribute, I get everything I wanted.<br /><br /><pre class="prettyprint">/// <summary><br />/// Ensures that an object's value is not equal to zero.<br />/// </summary><br />public class NonZeroAttribute : ValidationAttribute<br />{<br />    protected override ValidationResult IsValid(object value, ValidationContext validationContext)<br />    {<br />        ErrorMessage = "Please enter a value that is not equal to zero.";<br />        var badResult= new ValidationResult(this.ErrorMessageString) ;<br /><br />        if (value == null) return null;<br /><br />        double x = 0;<br />        if (double.TryParse(value.ToString(), out x) == false)<br />            return badResult;<br /><br />        ValidationResult result = value.Equals(0.0) ? badResult: null;<br />            <br />        return result;<br />    }<br />}</pre><br />The function first checks to see if the value is null. If it is, we let it go. We leave it up to the coder to use a [Required] attribute if necessary. Then we try to parse the object's value into a double. I chose a double because any numeric value should be able to be converted into a double safely. If the TryParse fails, the value is non-numeric. In that case, we return a bad result. I may have to rethink that part, because a non-numeric value is clearly "not zero." Finally, the parsed numeric value is compared to 0 and the result returned. So far, it works like a charm.<br /><br />With that class in place, I can easily remove my IDataErrorInfo code above and annotate the properties with the appropriate attribute(s);<br /><br /><pre class="prettyprint">[Required]<br />[NonZero]<br />[Range(0,double.MaxValue)]<br />public double NonZeroProperty<br />...<br /></pre><br />I'd be curious to hear others' thoughts on the pros and cons to this approach, as well as any optimizations I could make.